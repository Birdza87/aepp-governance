// ISC License
//
// Copyright (c) 2019, aeternity developers
//
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
// REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
// AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
// INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
// LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
// OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
// PERFORMANCE OF THIS SOFTWARE.


// THIS IS NOT SECURITY AUDITED
// DO NEVER USE THIS WITHOUT SECURITY AUDIT FIRST

namespace List =
  function map(f : 'a => 'b, l : list('a)) : list('b) =
    switch(l)
     [] => []
     e :: l' => f(e) :: map(f, l')

  function filter(f : ('a) => bool, l : list('a)) = filter'(f, l, [])
  private function filter'(f : ('a) => bool, l : list('a), acc : list('a)) =
    switch(l)
      [] => acc
      e :: l' =>
        if(f(e))
          filter'(f, l', e :: acc)
        else
          filter'(f, l', acc)

namespace Option =
  function is_defined(o : option('a)) : bool =
    switch(o)
      Some(_) => true
      None => false

contract Poll =
  record overview =
    { address : address
    , title : string
    , is_listed : bool
    , close_height : option(int)
    , votes_count : int }

  entrypoint overview : () => overview
  entrypoint voted_option : (address) => option(int)

// ACTUAL CONTRACT

contract Registry =

  type polls = map(int, Poll)

  // delegation from delegator to delegatee, delegatee will be globally allowed to take power of delegator
  // votes by delegator will overwrite delegation for one poll
  type delegations = map(address, address)

  record state =
    { polls : polls
    , seq_id : int
    , delegations : delegations }

  record voted_or_delegated =
    { has_voted : bool
    , has_delegated : bool
    , delegated_to : option(address)
    , voter_or_delegatee_vote_option : option(int) }

  entrypoint init() : state =
    { polls = {},
      seq_id = 0,
      delegations = {} }

  // STATEFULL FUNCTIONS

  stateful entrypoint add_poll(poll: Poll) =
    put(state{ polls[state.seq_id] = poll, seq_id = state.seq_id + 1 })

  stateful entrypoint delegate(delegatee : address) =
    require(Call.caller != delegatee, "CALLER_IS_DELEGATEE_DISALLOWED")
    put(state{ delegations[Call.caller] = delegatee })

  stateful entrypoint revoke_delegation() =
    put(state{ delegations = Map.delete(Call.caller, state.delegations) })

  // STATELESS PUBLIC FUNCTIONS

  entrypoint get_state() : state = state

  entrypoint delegations(account : address) : delegations =
    let filter_delegations_account = (delegation_tuple) =>
      switch(delegation_tuple)
        (delegator, delegatee) => delegator == account || delegatee == account
    Map.from_list(List.filter(filter_delegations_account, Map.to_list(state.delegations)))

  entrypoint has_voted_or_delegated(account : address, poll_id : int) : voted_or_delegated =
    let account_delegated = Map.lookup(account, state.delegations)
    let poll = require_poll_by_id(poll_id)
    let voted_option = poll.voted_option(account)
    let voter_or_delegatee_vote_option =
      switch((voted_option, account_delegated))
        (Some(voted_voter), _) => Some(voted_voter)
        (None, Some(delegatee)) => poll.voted_option(delegatee)
        _  => None
    { has_voted = Option.is_defined(voted_option),
      has_delegated = Option.is_defined(account_delegated),
      delegated_to = account_delegated,
      voter_or_delegatee_vote_option = voter_or_delegatee_vote_option }

  entrypoint polls_overview() : list((int, Poll.overview)) =
    let zip_seq_id_poll_overview = (seq_poll_tuple) =>
      switch(seq_poll_tuple)
        (seq_id, poll) => (seq_id, poll.overview())
    List.map(zip_seq_id_poll_overview, Map.to_list(state.polls))

  // INTERNAL HELPER FUNCTIONS

  function require_poll_by_id(poll_id : int) : Poll =
    switch(Map.lookup(poll_id, state.polls))
      None => abort("POLL_ID_NOT_KNOWN")
      Some(poll) => poll

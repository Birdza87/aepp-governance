// ISC License
//
// Copyright (c) 2019, aeternity developers
//
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
// REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
// AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
// INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
// LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
// OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
// PERFORMANCE OF THIS SOFTWARE.


// THIS IS NOT SECURITY AUDITED
// DO NEVER USE THIS WITHOUT SECURITY AUDIT FIRST

namespace List =
  function map(f : 'a => 'b, l : list('a)) : list('b) =
    switch(l)
     [] => []
     e :: l' => f(e) :: map(f, l')

  function filter(f : ('a) => bool, l : list('a)) = filter'(f, l, [])
  private function filter'(f : ('a) => bool, l : list('a), acc : list('a)) =
    switch(l)
      [] => acc
      e :: l' =>
        if(f(e))
          filter'(f, l', e :: acc)
        else
          filter'(f, l', acc)

namespace Tuple =
  function pair_second(tuple) =
    switch(tuple)
      (_, e) => e

namespace Option =
  function is_defined(o : option('a)) : bool =
    switch(o)
      Some(_) => true
      None => false

contract Poll =
  record overview =
    { address : address
    , title : string
    , is_listed : bool
    , close_height : option(int)
    , votes_count : int
    , is_closed : bool }

  entrypoint overview : () => overview
  entrypoint voted_option : (address) => option(int)
  entrypoint is_author : (address) => bool
  entrypoint has_voted : (address) => bool
  entrypoint is_closed : (bool) => bool

// ACTUAL CONTRACT

contract Registry =

  type polls = map(int, Poll)

  // delegation from delegator to delegatee, delegatee will be globally allowed to take power of delegator
  // votes by delegator will overwrite delegation for one poll
  type delegations = map(address, address)

  record state =
    { polls : polls
    , seq_id : int
    , delegations : delegations }

  record voted_or_delegated =
    { has_voted : bool
    , has_delegated : bool
    , delegated_to : option(address)
    , voter_or_delegatee_vote_option : option(int) }

  entrypoint init() : state =
    { polls = {},
      seq_id = 0,
      delegations = {} }

  // STATEFULL FUNCTIONS

  stateful entrypoint add_poll(poll: Poll) : int =
    let poll_seq_id = state.seq_id
    put(state{ polls[state.seq_id] = poll, seq_id = state.seq_id + 1 })
    poll_seq_id

  stateful entrypoint delegate(delegatee : address) =
    require(Call.caller != delegatee, "CALLER_IS_DELEGATEE_DISALLOWED")
    put(state{ delegations[Call.caller] = delegatee })

  stateful entrypoint revoke_delegation() =
    put(state{ delegations = Map.delete(Call.caller, state.delegations) })

  // STATELESS PUBLIC FUNCTIONS

  entrypoint get_state() : state = state

  entrypoint delegatee(account : address) : option(address) =
    Map.lookup(account, state.delegations)

  entrypoint delegators(account : address) : delegations =
    let filter_delegations_account = (delegation_tuple) => Tuple.pair_second(delegation_tuple) == account
    Map.from_list(List.filter(filter_delegations_account, Map.to_list(state.delegations)))

  entrypoint polls_overview() : list((int, Poll.overview)) =
    map_poll_overview(Map.to_list(state.polls))

  entrypoint polls_by_voter(voter : address) : list((int, Poll.overview)) =
    find_polls_filter(((poll) => poll.has_voted(voter)))

  entrypoint polls_by_author(author : address) : list((int, Poll.overview)) =
    find_polls_filter(((poll) => poll.is_author(author)))

  entrypoint polls_by_closed(closed : bool) : list((int, Poll.overview)) =
    find_polls_filter(((poll) => poll.is_closed(closed)))

  // INTERNAL HELPER FUNCTIONS

  function find_polls_filter(poll_filter : ((Poll) => bool)) : list((int, Poll.overview)) =
    let filter_polls_list = (seq_poll_tuple) => switch(seq_poll_tuple)
      (_, poll) => poll_filter(poll)
    map_poll_overview(List.filter(filter_polls_list, Map.to_list(state.polls)))

  function map_poll_overview(poll_seq_list : list((int, Poll))) : list((int, Poll.overview)) =
    let zip_seq_id_poll_overview = (seq_poll_tuple) => switch(seq_poll_tuple)
      (seq_id, poll) => (seq_id, poll.overview())
    List.map(zip_seq_id_poll_overview, poll_seq_list)

  function require_poll_by_id(poll_id : int) : Poll =
    switch(Map.lookup(poll_id, state.polls))
      None => abort("POLL_ID_NOT_KNOWN")
      Some(poll) => poll
